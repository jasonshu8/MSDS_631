import math
import numpy as np

#From Euler Problem 1, finds all numbers that can divide into a number. Divisors can be multiple values.
def find_nums_divisible_by_divisors(max_num,divisors):
    divisible = []
    for i in range(1, max_num):
        for n in divisors:
            if (i % n == 0):
                divisible.append(i)
    return divisible

#From Euler Problem 2, Fibonacci sequence which is generated by summing the last two numbers in a sequence.
def find_fibonacci_sequence(start_value,max_value):
    values = [start_value]
    for i in range(start_value,max_value):
        if (len(values) == 1):
            values.append(i + start_value)
        elif (i == values[-1] + values[-2]):
            values.append(i)
    return values

#From Euler Problem 3, Find all squared prime factors.
def find_squared_prime_factors(input_number):
    factors = []
    if input_number > 1:
        for i in range(2, int(math.sqrt(input_number)) + 1):
            if (input_number % i == 0):
                factors.append(i)
    else:
        return "No Prime Factors"
    return factors

#From Euler Problem 3, Find out if a number is prime.
def check_if_prime_number(number):
    if number <= 1:
        return False
    for i in range(2, (int(number**0.5)+1)):
        if number % i == 0:
            return False
    return True

#From Euler Problem 4, Find possible palindromes ie palindromic number reads the same both ways

def find_all_possible_values_equating_palindrome(min_list_whole_number, max_list_whole_number):
    potential_palindromes = []
    for i in range(min_list_whole_number, max_list_whole_number):
        a_to_string = str(i)
        b_to_string = ''.join(reversed(str(i)))
        join_strings_make_int = int(a_to_string + b_to_string)
        potential_palindromes.append(join_strings_make_int)
    return set(potential_palindromes)

def find_palindromes(possible_palindromes, min_list_whole_number, max_list_whole_number):
    palindromes = []
    for i in possible_palindromes:
        for n in range(min_list_whole_number, max_list_whole_number):
            if (i % n == 0) and (i / n >= min_list_whole_number) and (i / n < max_list_whole_number):
                palindromes.append(i)
    return palindromes

#From Euler Problem 5,



#From Euler Problem 6

def find_sum_of_squares(natural_low,natural_high):
    sum_of_the_squares = 0
    for i in range(natural_low,natural_high+1):
        squared = i**2
        sum_of_the_squares += squared
    return sum_of_the_squares

def find_square_of_sum(natural_low,natural_high):
    summed_values = 0
    for n in range(natural_low,natural_high+1):
        summed_values += n
    square_of_the_sum = summed_values**2
    return square_of_the_sum

#From Euler Problem 7, finds every prime number and adds to list

def find_every_prime_number(prime_number_length):
    start_prime_numbers = 1
    prime_numbers = []
    while len(prime_numbers) < prime_number_length:
        if check_if_prime_number(start_prime_numbers) is True:
            prime_numbers.append(start_prime_numbers)
            start_prime_numbers += 1
        else:
            start_prime_numbers += 1
    else:
        return prime_numbers

# From Euler Problem 8,  creates a dictionary of all series and their product

def find_product_of_adjacents(number,number_of_adjacents):
    import numpy as np
    list_of_numbers = [int(i) for i in str(number)]
    digit_place = 0
    combination_sets = {}
    last_combination = len(list_of_numbers) - number_of_adjacents + 1
    while digit_place < last_combination:
        set_of_numbers = list_of_numbers[digit_place:(number_of_adjacents + digit_place)]
        numbers_into_int = int("".join(map(str, set_of_numbers)))
        product_of_numbers = np.prod(set_of_numbers)
        digit_place += 1
        combination_sets[numbers_into_int] = product_of_numbers
    return combination_sets